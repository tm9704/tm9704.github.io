---
title: "Kotlin(4) - 코틀린 자료형 검사 & 변환"
excerpt: "Kotlin NPE Test"
toc: true
toc_sticky: true
categories:
  - Kotlin
tags:
  - Kotlin
date: "2021-12-04 18:30:00"
last_modified_at: "2021-12-04 19:00:00"
---

코틀린은 변수를 사용할 때 반드시 값이 할당되어 있어야 한다는 원칙이 있습니다.<br/>

만약, 값이 할당되지 않은 변수를 사용하면 오류가 발생하는데,<br/>
값이 없는 상태를 null이라고 부릅니다.<br/>

null 상태인 변수를 허용하려면 물음표(?) 기호를 사용해 선언해야 합니다.<br/>

## 1. null을 허용한 변수 검사하기

프로그램이 실행되는 도중에 값이 null인 변수에 접근하려 하면 NPE 예외 오류가 발생합니다.<br/>
그러나 코틀린은 변수에 아예 null을 허용하지 않습니다.<br/>

1. 변수에 null 할당하기<br/>

   ```
    var str1 : String = "Hello Kotlin"
    //str1 = null => 오류 null을 허용하지않음
    println("str1: $str1")
   ```

   위의 코드를 실행하면 null 값이 할당될 수 없다는 오류 메세지가 나타납니다.<br/>
   변수에 null 할당을 허용하려면 자료형 뒤에 물음표(?) 기호를 명시해야 합니다.<br/>

   ```
    var str1 : String? = "Hello Kotlin"
    str1 = null
    println("str1: $str1")
   ```

   str1 변수에 null을 할당할 수 있으며, 변수의 null 허용 여부에 따라<br/>
   String과 String?은 서로 다른 자료형입니다.<br/>

2. 세이프 콜과 non-null 단정 기호<br/>

   ```
   var str1: String? = "Hello Kotlin"
   str1 = null
   println("str1: $str1 length: ${str1.length}") //null을 허용하면 length가 실행될 수 없음
   ```

   위 코드는 실행이 불가능하며, String?형에서는 세이프 콜(?.)이나 non-null 단정 기호(!!.)만 허용합니다.<br/>

   1. 세이프콜<br/>

      null이 할당되어 있을 가능성이 있는 변수를 검사하여 안전하게 호출하도록 도와주는 기법<br/>

      ```
      var str1: String? = "Hello Kotlin"
      str1 = null
      println("str1: $str1 length: ${str1?.length}") // str1을 세이프 콜로 안전하게 호출
      ```

      str1을 검사한 다음 null이 아니면 str1의 멤버 변수인 length에 접근해 값을 읽습니다.<br/>
      반면, str1에 아무런 값이 없을 경우 length에 접근하지 않고 그대로 null을 출력합니다.<br/>

   2. non-null 단정기호<br/>

      non-null 단정 기호는 변수에 할당된 값이 null이 아님을 단정하는 기호입니다.<br/>
      그러므로 컴파일러가 null 검사 없이 무시합니다.<br/>

      따라서 변수에 null이 할당되어 있어도 컴파일은 진행되나, 실행 중에 NPE가 발생합니다.<br/>

      ```
      println("str1: $str1 length: ${str1!!.length}") //NPE 강제 발생
      ```

3. 조건문을 활용한 null을 허용한 변수 검사<br/>

   세이프 콜이나 단정 기호를 사용하는 방법 대신 조건문으로 null을 허용한 변수를 검사해도 됩니다.<br/>
   즉, null을 허용한 변수의 null 상태 가능성을 검사하기만 하면 코틀린 컴파일러는 오류를 발생시키지 않습니다.<br/>

   ```
   fun main(){
       var str1: String? = "Hello Kotlin"
       str1 = null

       var len = if(str1 != null) str1.length else -1
       println("str1: $str1 length: ${len}")
   }
   ```

4. 세이프 콜과 엘비스 연산자 활용<br/>

   null을 허용한 변수를 조금 더 안전하게 사용하려면 세이프 콜(?.)과<br/>
   엘비스(Elvis) 연산자 ?:를 함께 사용하면 됩니다.<br/>

   엘비스 연산자는 변수가 null인지 아닌지 검사하여 null이 아니라면,<br/>
   그대로 왼쪽 식을 실행하고 null이면 오른쪽 식을 실행합니다.<br/>

   ```
    var str1: String? = "Hello Kotlin"
    str1 = null
    println("str1 = $str1 length: ${str1?.length ?: -1}") //세이프 콜과 엘비스 연산자 활용
   ```

   위의 **_${str1?.length ?: -1}_**은 **_if(str1!=null) str1.length else -1_**과 동일합니다.<br/>

## 2. 자료형 비교하고 검사하고 변환하기

코틀린의 자료형은 모두 참조형으로 선언한다고 배웠습니다.<br/>
하지만 컴파일될 때 Int, Long, Short와 같은 자료형은 기본형 자료형으로 변환됩니다.<br/>

각각 저장방식이 다르기 때문에 자료형을 비교하거나 검사할 때는 이런 특징을 잘 이해해야 합니다.<br/>

코틀린은 자료형이 서로 다른 변수를 비교하거나 연산할 수 없습니다.<br/>

1. 자료형 변환<br/>

   코틀린은 자바같은 언어처럼 자료형이 다른 변수에 재할당 하면 자동 형변환이 되지 않습니다.<br/>
   (Type Mismatch 오류 발생)<br/>

   ```
    val a: Int = 1 //Int형 변수 a를 선언하고 1을 할당
    val b: Double = a //자료형 불일치로 오류 발생
    val c: Int = 1.1 //자료형 불일치 오류 발생
   ```

   만약 자료형을 변환해 할당하고 싶다면 자료형 변환 메서드가 필요합니다.<br/>

   ```
   val b: Doulbe = a.toDouble()
   ```

   그러나 표현식에서 자료형이 서로 다른 값을 연산할 때는 자료형이 표현할 수 있는<br/>
   범위가 큰 자료형으로 자동 형 변환하여 연산합니다.<br/>

   ```
   var result = 1L + 3 //Long + Int -> result는 Long
   ```

2. 기본형과 참조형 자료형의 비교 원리<br/>

   자료형을 비교할 때 단순히 값만 비교하는 방법과 참조 주소까지 비교하는 방법이 있습니다.<br/>

   단순히 값만 비교할 경우 이중 등호 (==)를 사용하며<br/>
   (주소는 상관 없음)<br/>
   참조 주소를 비교하려면 삼중 등호(===)를 사용합니다.<br/>
   (값은 상관 없음)<br/>

   ```
   val a: Int = 128
   val b: Int = 128
   println(a == b)
   println(a === b)
   ```

   위의 코드의 경우는 Int형 같은 경우 컴파일러가 자동으로 int로 변환해주기 때문에,<br/>
   삼중 등호가 비교하는 값도 저장된 값이 128입니다.<br/>

   참조 주소까지 달라지는 것은 null을 허용한 변수의 경우 같은 값을 저장해도<br/>
   이중등호와 삼중등호를 사용한 결과가 다릅니다.<br/>

   ```
   val a: Int = 128 //스택 저장
   val b: Int? = 128 // 참조형으로 저장

   println(a == b)
   println(a === b)
   ```

   Int형으로 선언된 a는 기본형으로 변환되어 스택에 128이라는 값 자체를 저장합니다.<br/>
   Int?형으로 선언된 b는 참조형으로 저장되므로 b에는 128이 저장된 힙의 참조 주소가 저장되어 있습니다.<br/>

   즉, a와 b를 삼중 등호로 비교하면 false가 나옵니다.<br/>

   ```
   fun main() {
      val a: Int = 128
      val b = a
      println(a === b)

      val c: Int? = a
      val d: Int? = a
      val e: Int? = c
      println(c == d)
      println(c === d)
      println(c === e)
   }
   ```

   위 코드에서 a와 b는 참조형인 Int로 선언되었지만<br/>
   코틀린 컴파일러에 의해 기본형으로 변환되어 값 자체가 스택에 저장되어 있고<br/>
   c, d, e는 참조형으로<br/>
   d와 e는 힙 메모리에 있는 동일한 객체를 참조하고 c는 다른 객체를 참조합니다<br/><br/>
   따라서 **c == d**는 값을 비교함으로 같지만 **c === d**는 주소를 비교하므로 false를 출력합니다.<br/>
   c와 e의 경우에는 e가 c의 참조주소를 저장하기 때문에 이중, 삼중등호로 비교한 값이 모두 동일합니다.<br/>

3. 스마트 캐스트 알아보기

   만약 어떤 값이 정수일 수도 있고, 실수일 수도 있다면<br/>
   그때마다 자료형을 변환해도 되지만 컴파일러가 자동으로 형 변환을 하는 **스마트 캐스트**를 사용하는 것이 더 편리합니다.<br/><br/>

   대표적으로 스마트 캐스트가 적용되는 자료형은 Number형이 있습니다.<br/>
   Number형을 사용하면 숫자를 저장하기 위한 특수한 자료형 객체를 만듭니다.<br/>
   Number형으로 정의된 변수에는 저장되는 값에 따라 정수형이나 실수형 등으로 자료형이 변환됩니다.<br/>

   ```
   fun main(){
      var test: Number = 12.2 // 12.2로 인해 Float형으로 스마트 캐스트

      test = 12 // Int형으로 스마트 캐스트

      test = 120L // Long형으로 스마트 캐스트

      test += 12.0f // Float형으로 스마트 캐스트
   }
   ```

   위의 코드는 Number형과 스마트 캐스트를 사용한 예제입니다.<br/>

4. 자료형 검사하기

   변수의 자료형을 알아내는 방법은 is 키워드를 사용하는 것입니다.<br/>
   is는 왼쪽 항의 변수가 오른쪽 항의 자료형과 같으면 true, 아니면 false를 반환합니다.<br/>

   ```
   fun main() {
      val num = 256

      if(num is Int){ // num이 Int일 때
         print(num)
      }else if(num !is Int){ // num이 Int형이 아닐 때, !(num is Int)와 동일하다
         print("Not a Int")
      }
   }
   ```

   is는 변수의 자료형을 검사한 다음 그 변수를 해당 자료형으로 변환하는 기능도 있습니다.<br/>(이건 나중에 더 보겠습니다.)<br/><br/>

   Any형을 사용하면 자료형을 결정하지 않은 채로 변수를 선언할 수 있습니다.<br/>
   Any형은 코틀린의 최상위 기본 클래스로 어떠한 자료형으로도 변환될 수 있는 특수한 자료형입니다.<br/>
   이때 is를 사용하여 자료형을 검사하면 검사한 자료형으로 스마트 캐스트 됩니다.<br/>

   ```
   val x: Any
   x = "Hello"
   if(x is String){
      print(x.length) // x는 자동으로 String으로 스마트 캐스트
   }
   ```

5. as에 의한 스마트 캐스트
   as로 스마트 캐스트 할 수도 있는데, as는 형 변환이 가능하지 않으면 예외를 발생시킵니다.<br/>

   ```
   var x: String = y as String
   ```

   위의 코드에서 y가 null이 아니면 String으로 형 변환되어 x에 할당됩니다.<br/>
   y가 null이면 형 변환을 할 수 없으므로 예외가 발생합니다.<br/><br/>

   null 가능성을 고려하여 예외 발생을 피하려면 ? 기호를 사용해야합니다.<br/>

   ```
   var x: String? = y as? String
   ```

6. 묵시적 변환
   Any형은 자료형이 특별히 정해지지 않은 경우에 사용합니다.<br/>
   코틀린의 Any형은 모든 클래스의 뿌리이고, Int나 String, 사용자가 만든 클래스<br/>
   모두 Any형의 자식 클래스입니다.<br/>
   즉 코틀린의 모든 클래스는 Any 라는 슈퍼 클래스를 가집니다.<br/><br/>

   ```
   fun main(){
      checkArg("Hello")
      checkArg(5)
   }

   fun checkArg(x: Any){
      if(x is String){
         println("x is String: $x")
      }
      if(x is Int){
         println("x is Int: $x")
      }
   }
   ```

   위의 코드처럼 함수와 판단문을 사용해 언제든지 필요한 자료형에 따른 역할을 지정하여 처리할 수 있습니다.<br/>

## 3. 코틀린 연산자

1. 기본 연산자

   코틀린의 기본 연산자로는 산술, 대입, 증가, 감소, 비교, 논리연산자가 있습니다.<br/>

   산술: +, -, _, /, %<br/>
   대입: =, +=, -=, _=, /=, %= (가장 낮은 우선순위)<br/>
   증감: ++, -- (단항 연산자로 위치에 따라 연산이 달라짐)<br/>
   비교: >, <, >=, <=, ==, !=, ===, !==<br/>
   논리: &&, ||, !<br/><br/>

   비트 연산자는 기계가 이해할 수 있는 값인 0과 1을 처리하는데 사용합니다.<br/>
   보통 기기를 직접 제어할 때 사용합니다.<br/><br/>

   비트 연산을 위한 비트 메서드로는<br/>
   .shl(bits) : 비트를 bits만큼 왼쪽으로 이동(부호 있음)<br/>
   .shr(bits) : 비트를 bits만큼 오른쪽으로 이동(부호 있음)<br/>
   .ushr(bits) : 비트를 bits만큼 오른쪽으로 이동(부호 없음)<br/>
   .and(bits) : 비트와 bits를 표현하는 비트로 논리곱 연산<br/>
   .or(bits) : 비트와 bits를 표현하는 비트로 논리합 연산<br/>
   .xor(bits) : 비트와 bits를 표현하는 비트의 배타적 연산
   .inv() : 비트를 다 뒤집음<br/><br/>

2. 비트 이동 연산자
   위에서는 메서드를 살펴봤고 이제 연산자를 보겠습니다.<br/>

   shl, shr은 각각 비트를 왼쪽, 오른쪽으로 밀어낸 다음 사라진 비트의 값은 0으로 두고 부호 비트는 그대로 둡니다.<br/><br/>

   ushr은 제일 왼쪽 비트에 0을 밀어 넣으면서 오른쪽으로 비트가 이동합니다.<br/>
   즉, 부호 비트까지 포함하여 비트를 밀어냅니다.<br/>
   이러한 특징 때문에 음수인 경우 주의해서 사용해야 합니다.<br/>

   논리합 연산자 or은 두 수의 비트를 일대일 대응으로 비교하며, 하나라도 1이면 1을 반환합니다.<br/>
   논리곱 연산자 and는 두 수의 비트를 일대일 대응으로 비교하며, 둘 다 1이면 1을 반환합니다.<br/><br/>

   배타적합 연산자 xor은 두 비트 값을 비교하여 같으면 0을 다르면 1을 반환합니다.<br/>
   반전 연산자 inv는 비트를 다 뒤집습니다.<br/>
