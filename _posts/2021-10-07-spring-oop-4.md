---
title: "Spring(2) - 객체지향의 4대 특성"
excerpt: "Spring OOP Property"
toc: true
toc_sticky: true
categories:
  - Spring
tags:
  - Spring
date: "2021-10-07 14:25:00"
last_modified_at: "2021-10-07 14:50:00"
---

이번 포스트에서는 객체지향의 4대 특성에 대해 알아보겠습니다.<br/>

## 1. 캡슐화

첫번째 특성은 캡슐화입니다.<br/>

캡슐화는 객체의 속성(Variable)을 보호하기 위해서 사용합니다.<br/>

객체의 캡슐화는 현실 세계에서도 볼 수 있는데,<br/>
컴퓨터 본체 안에 수 많은 부품이 있지만, 전원을 켜기 위해서는 메인보드에 전기 신호를 직접 주는 것이 아닌,<br/>
외부 케이스에 있는 전원 버튼을 통해서 On/Off를 변경 합니다.<br/>

1. 메소드 설계

   - 속성이 선언되었으나, 이의 상태를 변경하는 메소드가 없다면 잘못 선언된 속성입니다.<br/>
     즉, 자신이 가지고 있는 속성에 대해서는 해당 상태를 변경하는 기능을 제공해야합니다.
   - 각각의 메소드는 서로 관련성이 있어야 합니다.<br/>
     차량의 렌탈/반납, 자동차 등록증 해지/등록 등 각 속성의 상대 되는 기능을 제공해야합니다.
   - 객체 안의 메소드는 객체 안의 속성을 처리해야 하며,<br/>
     다른 객체를 전달받아 해당 다른 객체에 정의된 속성을 직접 처리하면 안됩니다.<br/>
     (객체는 반드시 자신의 속성을 건드려야함)
   - 단, 메소드에 실행에 필요한 값들은 객체의 형태가 아닌 매개변수의 형태로 전달되어져야 합니다.<br/>
     (값 자체를 전달받음)
   - Getter / Setter 메소드<br/>
     외부에서 내부속성에 직접 접근하는 것이 아닌 Getter/Setter 메소드를 통해 접근시켜야 합니다.
   - CRUD 메소드<br/>
     데이터 처리를 위한 기본적인 CRUD 메소드를 제공해야합니다.<br/>
     (Create Read Update Delete)
   - Business Logic 메소드<br/>
     비즈니스 로직 처리를 위한 메소드를 제공해야합니다.<br/>
     (Service 별로 달라짐)
   - 객체의 생명 주기 처리 메소드<br/>
     흔히 destory(), disconnect()(<-> connect()) 등 소멸에 대한 메소드를 제공해야합니다.
   - 객체의 영구성 관리 메소드<br/>
     영구성(유효성) 속성에 대한 변경이 필요한 경우 외부에서는 접근이 불가능 하도록 private로 선언하며,<br/>
     내부의 다른 메소드를 통해서 사용되도록 해야 합니다.<br/>
   - 메소드의 속성은 반드시 1개에 속할 필요는 없으며, 여러 속성에 해당 될 수 있습니다.

2. 장점

   - 객체지향의 패러다임 중 하나인 **추상화**를 제공합니다.<br/>
     실제로 메소드가 어떻게 동작하는지는 외부에서는 이해할 필요가 없으며,<br/>
     이를 단순 호출만으로 해당 기능을 실행 할 수 있고,<br/>
     이를 통해 객체 단위로 프로그램 설계가 가능합니다.
   - 재사용성 향상<br/>
     한 객체에 관련된 속성 및 메소드는 모두 캡슐화의 형태로 제공됨으로,<br/>
     객체의 모듈성과 응집도가 높아집니다. 이를 통해 재사용성이 높아집니다.<br/>
   - 앞선 이유로 인해, 유지보수의 효율성이 향상됩니다.

3. 무결성 보장
   - 보통의 캡슐화 코딩이라고 한다면, 주로 **변수는 private**로 선언하고,<br/>
     **메소드를 public**으로 선언하는 형태를 많이 가지게 됩니다.<br/>
   - 이는 객체의 무결성을 위함입니다.<br/>
     Getter/Setter를 제외하고는 public 메소드는 입력된 매개변수를<br/>
     **Validation(확인)**한 후에 실행하는 것을 기본으로 합니다.<br/>
     Validation을 통하여, 객체의 값을 바꾸거나, 값의 대한 유효성을 가질 수 있습니다.<br/>
     (해당 메소드에서 허용하지 않는 범위 내에서 값이 호출된 경우 무시하거나 error를 발생)

## 2. 상속

객체 지향에서의 상속은, 속성의 상속이 아닌, 하위로 내려갈 수록 구체화 되는 것을 의미합니다.<br/>
(재사용의 의미로 사용하면 안됨)<br/>

- 상속의 효과
  1. 프로그램 구조에 대한 이해도 향상<br/>
     최상위 클래스의 구조를 보고, 하위 클래스의 동작을 이해 할 수 있다.
  2. 재사용성 향상<br/>
     상속을 이용하여, 해당 클래스에 필요한 속성 및 메소드를 모두 정의하지 않고,<br/>
     상속을 받아서 사용할 수 있다.<br/>
     (재사용의 목적으로만 사용하면 안됨)
  3. 확장성 향상<br/>
     일관된 형태의 클래스 객체를 추가할 수 있어, 간단하게 프로그램 확장이 가능
  4. 유지보수성 향상<br/>
     각 객체마다, 자신의 메소드를 정의하고 있다면, 코드 수정에서 많은 작업이 필요하지만,<br/>
     상속을 사용한 경우 일관된 형태로 작성이 가능

## 3. 다형성

- 다형성은 하나의 객체가 여러 개의 형태로 변화하는 것을 말합니다.<br/>
  이를 객체지향에서도 유사하게 사용합니다.
- 다형성을 하기 위해서는 오버라이딩을 통해 사용이 가능합니다.

## 4. 추상화

- 객체지향에서의 추상화는 모델링입니다.
- 구체적으로 공통적인 부분, 또는 특정 특성을 분리해서 재조합 하는 부분이 추상화 입니다.
- 앞에서 배운 다형성, 상속이 추상화에 속합니다.

각 특성들의 자세한 내용들은 Java 카테고리에서 자세하게 설명하고 있습니다.
